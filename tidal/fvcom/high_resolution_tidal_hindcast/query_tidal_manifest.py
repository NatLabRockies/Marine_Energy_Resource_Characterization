"""
Query library for tidal parquet partition manifests.

This module provides efficient spatial queries against the ultra-compact grid centroid
manifests generated by generate_parquet_partition_manifest_json.py.

Uses scipy.spatial.cKDTree for fast nearest-neighbor spatial indexing.
"""

import json
import re
from pathlib import Path
from typing import List, Tuple, Optional, Dict, Any
import numpy as np
from scipy.spatial import cKDTree


class TidalManifestQuery:
    """
    Query interface for tidal parquet partition manifests.

    Provides spatial query methods:
    - query_nearest_point: Find nearest grid to a point
    - query_all_within_rectangular_area: Find all grids in bounding box
    - query_all_on_line: Find grids along a line
    """

    @staticmethod
    def parse_wkt_polygon(wkt_string: str) -> List[List[float]]:
        """
        Parse WKT POLYGON string to list of coordinate pairs.

        Parameters
        ----------
        wkt_string : str
            WKT POLYGON string, e.g., "POLYGON ((lon1 lat1, lon2 lat2, ...))"

        Returns
        -------
        list of list of float
            List of [lon, lat] coordinate pairs in GeoJSON order

        Examples
        --------
        >>> wkt = "POLYGON ((-175.0 49.9, -174.9 49.9, -174.9 50.0, -175.0 50.0, -175.0 49.9))"
        >>> coords = TidalManifestQuery.parse_wkt_polygon(wkt)
        >>> len(coords)
        5
        """
        # Extract coordinate string from POLYGON ((...))
        match = re.search(r"POLYGON\s*\(\(([^)]+)\)\)", wkt_string)
        if not match:
            raise ValueError(f"Invalid WKT POLYGON format: {wkt_string}")

        coord_string = match.group(1)

        # Parse coordinate pairs
        coords = []
        for pair in coord_string.split(","):
            parts = pair.strip().split()
            if len(parts) != 2:
                raise ValueError(f"Invalid coordinate pair: {pair}")
            lon, lat = float(parts[0]), float(parts[1])
            coords.append([lon, lat])

        return coords

    def __init__(self, manifest_path: Path):
        """
        Initialize query interface by loading manifest and building KDTree.

        Parameters
        ----------
        manifest_path : Path
            Path to manifest.json file (ultra-compact format)
        """
        self.manifest_path = Path(manifest_path)
        self.manifest_dir = self.manifest_path.parent
        self.grids_dir = self.manifest_dir / "grids"

        # Load manifest
        with open(self.manifest_path, "r") as f:
            self.manifest = json.load(f)

        # Extract configuration
        self.version = self.manifest["version"]
        self.decimal_places = self.manifest["decimal_places"]
        self.grid_resolution_deg = self.manifest["grid_resolution_deg"]
        self.total_grids = self.manifest["total_grids"]

        # Extract grid centroids
        self.grid_lats = np.array(self.manifest["grid_centroids"]["lat"])
        self.grid_lons = np.array(self.manifest["grid_centroids"]["lon"])

        # Build KDTree for fast spatial queries
        # Stack lat/lon into (N, 2) array for KDTree
        self.grid_coords = np.column_stack([self.grid_lats, self.grid_lons])
        self.kdtree = cKDTree(self.grid_coords)

        print(f"Loaded manifest v{self.version} with {self.total_grids:,} grids")
        print(f"Grid resolution: {self.grid_resolution_deg}°")
        print(f"Spatial bounds: {self.manifest['spatial_bounds']}")

    def _centroid_to_grid_id(self, centroid_lat: float, centroid_lon: float) -> str:
        """
        Calculate grid ID from centroid coordinates.

        Reverse engineers the grid ID from the centroid by:
        1. Calculating corner coordinates (centroid - grid_res/2)
        2. Extracting integer and decimal components

        Parameters
        ----------
        centroid_lat : float
            Grid centroid latitude
        centroid_lon : float
            Grid centroid longitude

        Returns
        -------
        str
            Grid ID in format "lat_deg_lon_deg_lat_dec_lon_dec"
        """
        grid_res = self.grid_resolution_deg

        # Calculate top-left corner from centroid
        corner_lat = centroid_lat - grid_res / 2
        corner_lon = centroid_lon - grid_res / 2

        # Extract integer and decimal parts
        lat_deg = int(np.floor(corner_lat))
        lat_dec = int(round((corner_lat - lat_deg) * (10**self.decimal_places)))

        lon_deg = int(np.floor(corner_lon))
        lon_dec = int(round((corner_lon - lon_deg) * (10**self.decimal_places)))

        return f"{lat_deg}_{lon_deg}_{lat_dec}_{lon_dec}"

    def _load_grid_details(self, grid_id: str) -> Dict[str, Any]:
        """
        Load detailed grid information from grids/ subdirectory.

        Grid files are organized in nested directories:
        grids/lat_{lat_deg}/lon_{lon_deg}/{grid_id}.json

        Parameters
        ----------
        grid_id : str
            Grid identifier in format "lat_deg_lon_deg_lat_dec_lon_dec"

        Returns
        -------
        dict
            Grid details including points, bounds, location, temporal resolution
        """
        # Parse grid_id to extract lat_deg and lon_deg
        # Format: "lat_deg_lon_deg_lat_dec_lon_dec"
        parts = grid_id.split("_")
        lat_deg = parts[0]
        lon_deg = parts[1]

        # Construct path to nested grid file
        grid_file = (
            self.grids_dir / f"lat_{lat_deg}" / f"lon_{lon_deg}" / f"{grid_id}.json"
        )

        if not grid_file.exists():
            raise FileNotFoundError(f"Grid detail file not found: {grid_file}")

        with open(grid_file, "r") as f:
            return json.load(f)

    def query_nearest_point(
        self,
        lat: float,
        lon: float,
        max_distance_deg: Optional[float] = None,
        load_details: bool = True,
    ) -> Dict[str, Any]:
        """
        Find nearest grid to a given point.

        Parameters
        ----------
        lat : float
            Query latitude
        lon : float
            Query longitude
        max_distance_deg : float, optional
            Maximum distance threshold in degrees. If specified, returns None
            if nearest grid is farther than this distance.
        load_details : bool, default=True
            Whether to load full grid details from grids/ directory.
            If False, returns only centroid and distance.

        Returns
        -------
        dict
            Result dictionary with keys:
            - centroid: (lat, lon) tuple
            - distance_deg: distance in degrees
            - grid_id: grid identifier
            - details: grid details (if load_details=True)

            Returns None if max_distance_deg is exceeded.

        Examples
        --------
        >>> query = TidalManifestQuery(Path("manifests/v0.3.0/manifest.json"))
        >>> result = query.query_nearest_point(lat=49.94, lon=-174.96)
        >>> print(result['grid_id'])
        '49_-175_93_96'
        >>> print(result['distance_deg'])
        0.0045
        """
        query_point = np.array([[lat, lon]])

        # Query KDTree for nearest neighbor
        distance, index = self.kdtree.query(query_point, k=1)
        distance = distance[0]
        index = index[0]

        # Check distance threshold
        if max_distance_deg is not None and distance > max_distance_deg:
            return None

        # Get centroid coordinates
        centroid_lat = self.grid_lats[index]
        centroid_lon = self.grid_lons[index]

        # Calculate grid ID
        grid_id = self._centroid_to_grid_id(centroid_lat, centroid_lon)

        result = {
            "centroid": (float(centroid_lat), float(centroid_lon)),
            "distance_deg": float(distance),
            "grid_id": grid_id,
        }

        # Load full details if requested
        if load_details:
            result["details"] = self._load_grid_details(grid_id)

        return result

    def query_all_within_rectangular_area(
        self,
        lat_min: float,
        lat_max: float,
        lon_min: float,
        lon_max: float,
        max_distance_deg: Optional[float] = None,
        load_details: bool = True,
    ) -> List[Dict[str, Any]]:
        """
        Find all grids within a rectangular bounding box.

        Parameters
        ----------
        lat_min : float
            Minimum latitude
        lat_max : float
            Maximum latitude
        lon_min : float
            Minimum longitude
        lon_max : float
            Maximum longitude
        max_distance_deg : float, optional
            Additional buffer distance in degrees. If specified, includes grids
            within this distance of the bounding box edges.
        load_details : bool, default=True
            Whether to load full grid details for each result.

        Returns
        -------
        list of dict
            List of result dictionaries, each with keys:
            - centroid: (lat, lon) tuple
            - grid_id: grid identifier
            - details: grid details (if load_details=True)

        Examples
        --------
        >>> query = TidalManifestQuery(Path("manifests/v0.3.0/manifest.json"))
        >>> results = query.query_all_within_rectangular_area(
        ...     lat_min=49.9, lat_max=50.0,
        ...     lon_min=-175.0, lon_max=-174.9
        ... )
        >>> print(f"Found {len(results)} grids")
        Found 12 grids
        """
        # Simple bounding box filter
        if max_distance_deg is None:
            # No buffer - direct bounding box
            mask = (
                (self.grid_lats >= lat_min)
                & (self.grid_lats <= lat_max)
                & (self.grid_lons >= lon_min)
                & (self.grid_lons <= lon_max)
            )
            indices = np.where(mask)[0]
        else:
            # Use KDTree query with buffer distance
            # Query all points within max_distance of bounding box
            # Create test points along bounding box perimeter
            n_test = 100  # Number of test points per edge

            # Top and bottom edges
            top_edge = np.column_stack(
                [np.full(n_test, lat_max), np.linspace(lon_min, lon_max, n_test)]
            )
            bottom_edge = np.column_stack(
                [np.full(n_test, lat_min), np.linspace(lon_min, lon_max, n_test)]
            )

            # Left and right edges
            left_edge = np.column_stack(
                [np.linspace(lat_min, lat_max, n_test), np.full(n_test, lon_min)]
            )
            right_edge = np.column_stack(
                [np.linspace(lat_min, lat_max, n_test), np.full(n_test, lon_max)]
            )

            # Combine all edge points
            edge_points = np.vstack([top_edge, bottom_edge, left_edge, right_edge])

            # Query KDTree for all points within max_distance of edges
            indices_list = self.kdtree.query_ball_point(edge_points, r=max_distance_deg)

            # Flatten and get unique indices
            indices = np.unique(np.concatenate(indices_list))

        # Build results
        results = []
        for idx in indices:
            centroid_lat = self.grid_lats[idx]
            centroid_lon = self.grid_lons[idx]
            grid_id = self._centroid_to_grid_id(centroid_lat, centroid_lon)

            result = {
                "centroid": (float(centroid_lat), float(centroid_lon)),
                "grid_id": grid_id,
            }

            if load_details:
                result["details"] = self._load_grid_details(grid_id)

            results.append(result)

        return results

    def query_all_on_line(
        self,
        start_lat: float,
        start_lon: float,
        end_lat: float,
        end_lon: float,
        max_distance_deg: float = 0.1,
        max_points: Optional[int] = None,
        load_details: bool = True,
    ) -> List[Dict[str, Any]]:
        """
        Find all grids along a line segment.

        Parameters
        ----------
        start_lat : float
            Starting latitude
        start_lon : float
            Starting longitude
        end_lat : float
            Ending latitude
        end_lon : float
            Ending longitude
        max_distance_deg : float, default=0.1
            Maximum perpendicular distance from line in degrees.
            Only grids within this distance of the line are included.
        max_points : int, optional
            Maximum number of points to return. If specified, returns the
            closest max_points grids to the line, sorted by distance.
        load_details : bool, default=True
            Whether to load full grid details for each result.

        Returns
        -------
        list of dict
            List of result dictionaries, each with keys:
            - centroid: (lat, lon) tuple
            - grid_id: grid identifier
            - distance_from_line_deg: perpendicular distance from line
            - distance_along_line_deg: distance along line from start point
            - details: grid details (if load_details=True)

            Sorted by distance_along_line_deg.

        Examples
        --------
        >>> query = TidalManifestQuery(Path("manifests/v0.3.0/manifest.json"))
        >>> results = query.query_all_on_line(
        ...     start_lat=49.9, start_lon=-175.0,
        ...     end_lat=50.0, end_lon=-174.9,
        ...     max_distance_deg=0.05
        ... )
        >>> for r in results[:5]:
        ...     print(f"Grid {r['grid_id']}: {r['distance_along_line_deg']:.4f}° along line")
        """
        # Calculate line parameters
        line_start = np.array([start_lat, start_lon])
        line_end = np.array([end_lat, end_lon])
        line_vec = line_end - line_start
        line_length = np.linalg.norm(line_vec)
        line_unit = line_vec / line_length

        # Calculate perpendicular distance for all grid centroids
        # Vector from line start to each centroid
        centroid_vecs = self.grid_coords - line_start

        # Project onto line direction
        distances_along = np.dot(centroid_vecs, line_unit)

        # Calculate perpendicular component
        projections = np.outer(distances_along, line_unit)
        perpendicular_vecs = centroid_vecs - projections
        distances_perp = np.linalg.norm(perpendicular_vecs, axis=1)

        # Filter by perpendicular distance
        mask = distances_perp <= max_distance_deg

        # Also filter to points between start and end (with some buffer)
        mask &= (distances_along >= -max_distance_deg) & (
            distances_along <= line_length + max_distance_deg
        )

        indices = np.where(mask)[0]

        if len(indices) == 0:
            return []

        # Build results with distance information
        results = []
        for idx in indices:
            centroid_lat = self.grid_lats[idx]
            centroid_lon = self.grid_lons[idx]
            grid_id = self._centroid_to_grid_id(centroid_lat, centroid_lon)

            result = {
                "centroid": (float(centroid_lat), float(centroid_lon)),
                "grid_id": grid_id,
                "distance_from_line_deg": float(distances_perp[idx]),
                "distance_along_line_deg": float(distances_along[idx]),
            }

            if load_details:
                result["details"] = self._load_grid_details(grid_id)

            results.append(result)

        # Sort by distance along line
        results.sort(key=lambda x: x["distance_along_line_deg"])

        # Limit to max_points if specified
        if max_points is not None:
            # Sort by perpendicular distance to get closest points
            results_sorted_by_distance = sorted(
                results, key=lambda x: x["distance_from_line_deg"]
            )
            results = results_sorted_by_distance[:max_points]
            # Re-sort by distance along line
            results.sort(key=lambda x: x["distance_along_line_deg"])

        return results

    def generate_grid_boundaries_geojson(
        self, aggregation_deg: Optional[float] = None
    ) -> Dict[str, Any]:
        """
        Generate GeoJSON FeatureCollection of grid boundaries.

        Can generate either individual grid cells or aggregated regions.

        Parameters
        ----------
        aggregation_deg : float, optional
            If specified, groups grids into coarser regions (e.g., 0.1° boxes).
            If None (default), generates individual grid cells for all grids.

        Returns
        -------
        dict
            GeoJSON FeatureCollection with grid boundary polygons.

        Examples
        --------
        >>> query = TidalManifestQuery(Path("manifests/v0.3.0/manifest.json"))
        >>> # All individual grids
        >>> geojson = query.generate_grid_boundaries_geojson()
        >>> # Aggregated grids
        >>> geojson = query.generate_grid_boundaries_geojson(aggregation_deg=0.1)
        """
        half_grid = self.grid_resolution_deg / 2

        if aggregation_deg is None:
            # Generate individual grid cells for all grids (fully vectorized)
            print(f"Generating {self.total_grids:,} individual grid boundaries...")

            # Vectorized calculation of all grid corners
            lat_mins = self.grid_lats - half_grid
            lat_maxs = self.grid_lats + half_grid
            lon_mins = self.grid_lons - half_grid
            lon_maxs = self.grid_lons + half_grid

            # Build all features using list comprehension (Python-level vectorization)
            features = [
                {
                    "type": "Feature",
                    "geometry": {
                        "type": "Polygon",
                        "coordinates": [
                            [
                                [float(lon_mins[i]), float(lat_mins[i])],
                                [float(lon_maxs[i]), float(lat_mins[i])],
                                [float(lon_maxs[i]), float(lat_maxs[i])],
                                [float(lon_mins[i]), float(lat_maxs[i])],
                                [float(lon_mins[i]), float(lat_mins[i])],
                            ]
                        ],
                    },
                    "properties": {},
                }
                for i in range(len(self.grid_lats))
            ]

            print(f"Generated {len(features):,} grid boundaries")

        else:
            # Aggregated mode (fully vectorized)
            print(f"Aggregating grids into {aggregation_deg}° regions...")

            # Bin grids into aggregation boxes (vectorized)
            box_lats = np.floor(self.grid_lats / aggregation_deg) * aggregation_deg
            box_lons = np.floor(self.grid_lons / aggregation_deg) * aggregation_deg

            # Create unique box identifiers
            box_keys = np.column_stack([box_lats, box_lons])
            unique_boxes, inverse_indices, counts = np.unique(
                box_keys, axis=0, return_inverse=True, return_counts=True
            )

            # Vectorized bounds calculation for all unique boxes
            # Use pandas groupby for vectorized min/max operations
            import pandas as pd

            df = pd.DataFrame(
                {
                    "lat": self.grid_lats,
                    "lon": self.grid_lons,
                    "box_idx": inverse_indices,
                }
            )

            grouped = df.groupby("box_idx").agg(
                {"lat": ["min", "max"], "lon": ["min", "max"]}
            )

            lat_mins_agg = grouped["lat"]["min"].values - half_grid
            lat_maxs_agg = grouped["lat"]["max"].values + half_grid
            lon_mins_agg = grouped["lon"]["min"].values - half_grid
            lon_maxs_agg = grouped["lon"]["max"].values + half_grid

            # Build all features using list comprehension
            features = [
                {
                    "type": "Feature",
                    "geometry": {
                        "type": "Polygon",
                        "coordinates": [
                            [
                                [float(lon_mins_agg[i]), float(lat_mins_agg[i])],
                                [float(lon_maxs_agg[i]), float(lat_mins_agg[i])],
                                [float(lon_maxs_agg[i]), float(lat_maxs_agg[i])],
                                [float(lon_mins_agg[i]), float(lat_maxs_agg[i])],
                                [float(lon_mins_agg[i]), float(lat_mins_agg[i])],
                            ]
                        ],
                    },
                    "properties": {"grid_count": int(counts[i])},
                }
                for i in range(len(unique_boxes))
            ]

            print(
                f"Aggregated {self.total_grids:,} grids into {len(features):,} regions"
            )

        geojson = {"type": "FeatureCollection", "features": features}

        return geojson

    def generate_location_boundaries_geojson(self) -> Dict[str, Any]:
        """
        Generate GeoJSON FeatureCollection of location boundaries from manifest.

        Uses the geospatial_bounds (WKT POLYGON) from each location in the manifest.

        Returns
        -------
        dict
            GeoJSON FeatureCollection with location boundary polygons.
            Each feature has properties: location, label, point_count

        Examples
        --------
        >>> query = TidalManifestQuery(Path("manifests/v0.3.0/manifest.json"))
        >>> geojson = query.generate_location_boundaries_geojson()
        >>> print(f"Generated {len(geojson['features'])} location boundaries")
        """
        if "locations" not in self.manifest:
            raise ValueError(
                "Manifest does not contain 'locations' data. "
                "Please regenerate manifest with updated generate_parquet_partition_manifest_json.py"
            )

        locations = self.manifest["locations"]
        features = []

        for location_name, location_data in locations.items():
            # Check if geospatial_bounds exists
            if "geospatial_bounds" not in location_data:
                print(
                    f"Warning: Location '{location_name}' has no geospatial_bounds, skipping"
                )
                continue

            wkt_polygon = location_data["geospatial_bounds"]

            try:
                # Parse WKT POLYGON to coordinates
                coordinates = self.parse_wkt_polygon(wkt_polygon)

                # Create GeoJSON feature
                feature = {
                    "type": "Feature",
                    "geometry": {"type": "Polygon", "coordinates": [coordinates]},
                    "properties": {
                        "location": location_name,
                        "label": location_data.get("label", location_name),
                        "point_count": location_data.get("point_count", 0),
                    },
                }

                features.append(feature)

            except ValueError as e:
                print(
                    f"Warning: Could not parse geospatial_bounds for location '{location_name}': {e}"
                )
                continue

        geojson = {"type": "FeatureCollection", "features": features}

        print(f"Generated {len(features)} location boundary polygons")

        return geojson


def main():
    """
    Example usage of TidalManifestQuery.
    """
    # Example manifest path (adjust for your environment)
    manifest_path = Path(
        "/projects/hindcastra/Tidal/datasets/high_resolution_tidal_hindcast/manifests/v0.3.0/manifest.json"
    )

    if not manifest_path.exists():
        print(f"Manifest not found at {manifest_path}")
        print(
            "Please update the path in the script or run generate_parquet_partition_manifest_json.py first."
        )
        return

    # Initialize query interface
    query = TidalManifestQuery(manifest_path)

    print("\n" + "=" * 80)
    print("Example 1: Query nearest point")
    print("=" * 80)

    result = query.query_nearest_point(lat=49.94, lon=-174.96, load_details=False)
    if result:
        print("Query point: (49.94, -174.96)")
        print(f"Nearest grid: {result['grid_id']}")
        print(f"Grid centroid: {result['centroid']}")
        print(f"Distance: {result['distance_deg']:.6f}°")

    print("\n" + "=" * 80)
    print("Example 2: Query rectangular area")
    print("=" * 80)

    results = query.query_all_within_rectangular_area(
        lat_min=49.9, lat_max=50.0, lon_min=-175.0, lon_max=-174.9, load_details=False
    )
    print("Bounding box: lat=[49.9, 50.0], lon=[-175.0, -174.9]")
    print(f"Found {len(results)} grids")
    if results:
        print("First 5 grids:")
        for r in results[:5]:
            print(f"  {r['grid_id']}: {r['centroid']}")

    print("\n" + "=" * 80)
    print("Example 3: Query along line")
    print("=" * 80)

    results = query.query_all_on_line(
        start_lat=49.9,
        start_lon=-175.0,
        end_lat=50.0,
        end_lon=-174.9,
        max_distance_deg=0.05,
        max_points=10,
        load_details=False,
    )
    print("Line: (49.9, -175.0) → (50.0, -174.9)")
    print("Max distance from line: 0.05°")
    print("Max points: 10")
    print(f"Found {len(results)} grids")
    if results:
        print("Grids along line:")
        for r in results:
            print(
                f"  {r['grid_id']}: {r['distance_along_line_deg']:.4f}° along, {r['distance_from_line_deg']:.4f}° perp"
            )


if __name__ == "__main__":
    main()
